{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"JUSTKIDDING","url":"http://blog.wangjin.online"},"pages":[{"title":"","date":"2019-03-22T08:45:46.632Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"404.html","permalink":"http://blog.wangjin.online/404.html","excerpt":"","text":""},{"title":"标签","date":"2017-04-10T04:15:00.000Z","updated":"2019-03-22T08:45:46.640Z","comments":false,"path":"tags/index.html","permalink":"http://blog.wangjin.online/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VS Code Prettier插件默认单引号和不添加分号","slug":"VS-Code-Prettier插件默认单引号和不添加分号","date":"2019-03-22T08:41:07.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2019/03/22/VS-Code-Prettier插件默认单引号和不添加分号/","link":"","permalink":"http://blog.wangjin.online/2019/03/22/VS-Code-Prettier插件默认单引号和不添加分号/","excerpt":"","text":"VS Code Prettier 插件设置不自动添加行位分号和不将单引号修改为双引号12\"prettier.semi\": false -- 行尾不添加分号\"prettier.singleQuote\": true, -- 不转换双引号，默认使用单引号","categories":[],"tags":[{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"http://blog.wangjin.online/tags/Visual-Studio-Code/"},{"name":"VS Code","slug":"VS-Code","permalink":"http://blog.wangjin.online/tags/VS-Code/"},{"name":"Prettier","slug":"Prettier","permalink":"http://blog.wangjin.online/tags/Prettier/"}]},{"title":"Java枚举","slug":"Java枚举","date":"2019-03-15T08:06:12.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2019/03/15/Java枚举/","link":"","permalink":"http://blog.wangjin.online/2019/03/15/Java枚举/","excerpt":"在 Java 1.5 之前，传统定义枚举的方式是借用定义常量的方式，例如定义颜色： 123public static final int RED = 1;public static final int YELLOW = 2;public static final int BLUE = 3; 在 Java 1.5 中增加了新的引用类型枚举。Java 的枚举类型的父类均为 java.lang.Enum，枚举本质上是 int 值。使用枚举方式定义颜色： 123public enum Color &#123; RED,YELLOW,BLUE;&#125;","text":"在 Java 1.5 之前，传统定义枚举的方式是借用定义常量的方式，例如定义颜色： 123public static final int RED = 1;public static final int YELLOW = 2;public static final int BLUE = 3; 在 Java 1.5 中增加了新的引用类型枚举。Java 的枚举类型的父类均为 java.lang.Enum，枚举本质上是 int 值。使用枚举方式定义颜色： 123public enum Color &#123; RED,YELLOW,BLUE;&#125; Enmu包含两个属性name和ordinal以及两个对应的方法name()和ordinal()。两个方法都被声明成 final，不可以被覆盖： 1234567public final String name() &#123; return name;&#125;public final int ordinal() &#123; return ordinal;&#125; ordinal()方法返回ordinal属性值，该属性为枚举值的索引，类型为int，默认从0开始。因此，按照定义枚举的顺序 RED.ordinal() = 0YELLOW.ordinal() = 1BLUE.ordinal() = 2 枚举提供编译时的类型安全检查声明方法的参数为枚举型时，则可以保证传递到该方法的参数必须为非 null 值且必须为枚举型的任一枚举值。 枚举禁止 clone枚举重写了 clone()方法，调用 clone 会抛出CloneNotSupportedException异常： 123protected final Object clone() throws CloneNotSupportedException &#123; throw new CloneNotSupportedException();&#125; 枚举不会被 finalize1234/** * enum classes cannot have finalize methods. */protected final void finalize() &#123; &#125; 枚举禁用了反序列化1234567891011/** * prevent default deserialization */private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; throw new InvalidObjectException(\"can't deserialize enum\");&#125;private void readObjectNoData() throws ObjectStreamException &#123; throw new InvalidObjectException(\"can't deserialize enum\");&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.wangjin.online/tags/Java/"},{"name":"枚举","slug":"枚举","permalink":"http://blog.wangjin.online/tags/枚举/"},{"name":"Enum","slug":"Enum","permalink":"http://blog.wangjin.online/tags/Enum/"}]},{"title":"Docker Compose学习笔记","slug":"Docker-Compose学习笔记","date":"2018-09-08T06:16:36.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2018/09/08/Docker-Compose学习笔记/","link":"","permalink":"http://blog.wangjin.online/2018/09/08/Docker-Compose学习笔记/","excerpt":"","text":"简介Docker Compose是一个用于定义和运行多容器Docker应用程序的工具。通过使用YAML文件来配置应用程序的服务，并使用docker-compose相关命令从配置中创建并启动所有服务。 使用Compose通常分为以下三部： 使用Dockerfile定义应用 使用docker-compose.yml定义服务 使用docker-compose up构建并启动应用 docker-compose.yml配置文件一般长这样：123456789101112131415version: '3'services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redisvolumes: logvolume01: &#123;&#125; 安装Docker Compose（Linux）安装 运行下面的命令下载最新的Docker Compose 1$ sudo curl -L \"https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 为docker-compose命令添加可执行权限 1$ sudo chmod +x /usr/local/bin/docker-compose 测试安装是否正确 1$ docker-compose --version 卸载1$ sudo rm /usr/local/bin/docker-compose 官方Starting Up步骤一：设置 创建一个测试目录 12$ mkdir composetest$ cd composetest 创建一个名为app.py的文件： 1234567891011121314151617181920212223242526272829import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host='redis', port=6379)def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5)@app.route('/')def hello(): count = get_hit_count() return 'Hello World! I have been seen &#123;&#125; times.\\n'.format(count)if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", debug=True) 上述例子中的redis是redis容器的在应用所属网络上的hostname，多个docker应用处于相同网络下时，通过hostname即可互相访问。 创建另一个名为requirements.txt的文件并添加以下内容：12flaskredis 步骤二：创建Dockerfile在这个步骤中，创建一个Dockerfile来构建Docker镜像。这个镜像包含Python环境和Python应用所需的所有依赖。 在项目目录中创建一个名为Dockerfile的文件并添加以下内容：12345FROM python:3.4-alpineADD . /codeWORKDIR /codeRUN pip install -r requirements.txtCMD [\"python\", \"app.py\"] Dockerfile构建为镜像步骤： 以Python 3.4-alpine镜像为基础构建一个镜像 把当前目录.下的所有文件添加到镜像的/code目录中 设置工作目录为/code 运行安装Python依赖的命令 设置容器默认启动命令为python app.py 步骤三：在Compose文件中定义服务在项目目录中创建一个名为docker-compose.yml的文件并添加以下内容： 12345678version: '3'services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 上面这个Compose文件定义了两个服务，web和redis。 web服务： 使用当前目录下的Dockerfile所构建的镜像 在容器和宿主机中暴露5000端口，这是Flask web的默认端口 redis服务使用Docker Hub registry中的镜像构建。 步骤四：使用Compose构建和运行应用 在工程目录下执行docker-compose命令： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879$ docker-compose upBuilding webStep 1/5 : FROM python:3.4-alpine ---&gt; 73266cf72156Step 2/5 : ADD . /code ---&gt; 93d41f61c2f8Step 3/5 : WORKDIR /code ---&gt; Running in 74e35fbb2368Removing intermediate container 74e35fbb2368 ---&gt; 2dc16f910cceStep 4/5 : RUN pip install -r requirements.txt ---&gt; Running in c82ef26c57eaCollecting flask (from -r requirements.txt (line 1)) Downloading https://files.pythonhosted.org/packages/7f/e7/08578774ed4536d3242b14dacb4696386634607af824ea997202cd0edb4b/Flask-1.0.2-py2.py3-none-any.whl (91kB)Collecting redis (from -r requirements.txt (line 2)) Downloading https://files.pythonhosted.org/packages/3b/f6/7a76333cf0b9251ecf49efff635015171843d9b977e4ffcf59f9c4428052/redis-2.10.6-py2.py3-none-any.whl (64kB)Collecting Jinja2&gt;=2.10 (from flask-&gt;-r requirements.txt (line 1)) Downloading https://files.pythonhosted.org/packages/7f/ff/ae64bacdfc95f27a016a7bed8e8686763ba4d277a78ca76f32659220a731/Jinja2-2.10-py2.py3-none-any.whl (126kB)Collecting click&gt;=5.1 (from flask-&gt;-r requirements.txt (line 1)) Downloading https://files.pythonhosted.org/packages/34/c1/8806f99713ddb993c5366c362b2f908f18269f8d792aff1abfd700775a77/click-6.7-py2.py3-none-any.whl (71kB)Collecting Werkzeug&gt;=0.14 (from flask-&gt;-r requirements.txt (line 1)) Downloading https://files.pythonhosted.org/packages/20/c4/12e3e56473e52375aa29c4764e70d1b8f3efa6682bef8d0aae04fe335243/Werkzeug-0.14.1-py2.py3-none-any.whl (322kB)Collecting itsdangerous&gt;=0.24 (from flask-&gt;-r requirements.txt (line 1)) Downloading https://files.pythonhosted.org/packages/dc/b4/a60bcdba945c00f6d608d8975131ab3f25b22f2bcfe1dab221165194b2d4/itsdangerous-0.24.tar.gz (46kB)Collecting MarkupSafe&gt;=0.23 (from Jinja2&gt;=2.10-&gt;flask-&gt;-r requirements.txt (line 1)) Downloading https://files.pythonhosted.org/packages/4d/de/32d741db316d8fdb7680822dd37001ef7a448255de9699ab4bfcbdf4172b/MarkupSafe-1.0.tar.gzBuilding wheels for collected packages: itsdangerous, MarkupSafe Running setup.py bdist_wheel for itsdangerous: started Running setup.py bdist_wheel for itsdangerous: finished with status 'done' Stored in directory: /root/.cache/pip/wheels/2c/4a/61/5599631c1554768c6290b08c02c72d7317910374ca602ff1e5 Running setup.py bdist_wheel for MarkupSafe: started Running setup.py bdist_wheel for MarkupSafe: finished with status 'done' Stored in directory: /root/.cache/pip/wheels/33/56/20/ebe49a5c612fffe1c5a632146b16596f9e64676768661e4e46Successfully built itsdangerous MarkupSafeInstalling collected packages: MarkupSafe, Jinja2, click, Werkzeug, itsdangerous, flask, redisSuccessfully installed Jinja2-2.10 MarkupSafe-1.0 Werkzeug-0.14.1 click-6.7 flask-1.0.2 itsdangerous-0.24 redis-2.10.6Removing intermediate container c82ef26c57ea ---&gt; b7c7a9180594Step 5/5 : CMD [\"python\", \"app.py\"] ---&gt; Running in 874657b8b1c8Removing intermediate container 874657b8b1c8 ---&gt; 3398cf709b5cSuccessfully built 3398cf709b5cSuccessfully tagged composetest_web:latestWARNING: Image for service web was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.composetest_redis_1 is up-to-dateCreating composetest_web_1 ... doneAttaching to composetest_redis_1, composetest_web_1redis_1 | 1:C 08 Sep 07:35:46.399 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis_1 | 1:C 08 Sep 07:35:46.400 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=1, just startedredis_1 | 1:C 08 Sep 07:35:46.400 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.confredis_1 | 1:M 08 Sep 07:35:46.405 * Running mode=standalone, port=6379.redis_1 | 1:M 08 Sep 07:35:46.405 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.redis_1 | 1:M 08 Sep 07:35:46.405 # Server initializedredis_1 | 1:M 08 Sep 07:35:46.406 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.redis_1 | 1:M 08 Sep 07:35:46.406 * Ready to accept connectionsredis_1 | 1:signal-handler (1536392231) Received SIGTERM scheduling shutdown...redis_1 | 1:M 08 Sep 07:37:11.181 # User requested shutdown...redis_1 | 1:M 08 Sep 07:37:11.182 * Saving the final RDB snapshot before exiting.redis_1 | 1:M 08 Sep 07:37:11.188 * DB saved on diskredis_1 | 1:M 08 Sep 07:37:11.188 # Redis is now ready to exit, bye bye...redis_1 | 1:C 08 Sep 07:37:14.802 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis_1 | 1:C 08 Sep 07:37:14.802 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=1, just startedredis_1 | 1:C 08 Sep 07:37:14.802 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.confredis_1 | 1:M 08 Sep 07:37:14.803 * Running mode=standalone, port=6379.redis_1 | 1:M 08 Sep 07:37:14.804 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.redis_1 | 1:M 08 Sep 07:37:14.804 # Server initializedredis_1 | 1:M 08 Sep 07:37:14.804 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.redis_1 | 1:M 08 Sep 07:37:14.804 * DB loaded from disk: 0.000 secondsredis_1 | 1:M 08 Sep 07:37:14.804 * Ready to accept connectionsweb_1 | * Serving Flask app \"app\" (lazy loading)web_1 | * Environment: productionweb_1 | WARNING: Do not use the development server in a production environment.web_1 | Use a production WSGI server instead.web_1 | * Debug mode: onweb_1 | * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)web_1 | * Restarting with statweb_1 | * Debugger is active!web_1 | * Debugger PIN: 303-324-532 在浏览器输入http://localhost:5000/查看应用是否运行正常。 在终端中输入docker images ls查看本地镜像： 12345$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcomposetest_web latest 3398cf709b5c 5 minutes ago 78.4MBredis alpine 162794862d37 12 hours ago 30MBpython 3.4-alpine 73266cf72156 3 days ago 67.1MB 步骤五：修改Compose文件添加目录挂载修改docker-compose.yml，给web服务添加一个目录挂载 12345678910version: '3'services: web: build: . ports: - \"5000:5000\" volumes: - .:/code redis: image: \"redis:alpine\" volumes键值把当前目录挂载到容器内/code目录 步骤六：使用Compose重新构建和运行应用12345678910111213141516171819202122$ docker-compose upCreating network \"composetest_default\" with the default driverCreating composetest_web_1 ... doneCreating composetest_redis_1 ... doneAttaching to composetest_redis_1, composetest_web_1redis_1 | 1:C 08 Sep 08:00:35.940 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Ooredis_1 | 1:C 08 Sep 08:00:35.940 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=1, just startedredis_1 | 1:C 08 Sep 08:00:35.940 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.confredis_1 | 1:M 08 Sep 08:00:35.941 * Running mode=standalone, port=6379.redis_1 | 1:M 08 Sep 08:00:35.941 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.redis_1 | 1:M 08 Sep 08:00:35.941 # Server initializedredis_1 | 1:M 08 Sep 08:00:35.941 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.redis_1 | 1:M 08 Sep 08:00:35.941 * Ready to accept connectionsweb_1 | * Serving Flask app \"app\" (lazy loading)web_1 | * Environment: productionweb_1 | WARNING: Do not use the development server in a production environment.web_1 | Use a production WSGI server instead.web_1 | * Debug mode: onweb_1 | * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)web_1 | * Restarting with statweb_1 | * Debugger is active!web_1 | * Debugger PIN: 741-610-125 步骤七：试一下其他指令如果你想让你的服务在后台运行，给docker-compose up添加-d参数，并使用docker-compse ps查看当前的运行： 123456789$ docker-compose up -dCreating network \"composetest_default\" with the default driverCreating composetest_redis_1 ... doneCreating composetest_web_1 ... done$ docker-compse ps Name Command State Ports-------------------------------------------------------------------------------------composetest_redis_1 docker-entrypoint.sh redis ... Up 6379/tcpcomposetest_web_1 python app.py Up 0.0.0.0:5000-&gt;5000/tcp 使用docker-compose run指令可以在容器内运行指令，例如查看web服务所在容器的环境变量： 123456789$ docker-compose run web envPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME=e0e26cbbba01TERM=xtermLANG=C.UTF-8GPG_KEY=97FC712E4C024BBEA48A61ED3A5CA953F73C700DPYTHON_VERSION=3.4.9PYTHON_PIP_VERSION=18.0HOME=/root 如果使用docker-compose up -d启动应用，可以使用docker-compose stop指令停止应用。 docker-compose down指令用来关闭所有，包括启动的容器，如果加上--volumes也会删除挂载的目录。 Compose文件第3版编写指南Compose和Docker版本兼容性 Compose 文件格式 Docker Engine 版本 3.7 18.06.0+ 3.6 18.02.0+ 3.5 17.12.0+ 3.4 17.09.0+ 3.3 17.06.0+ 3.2 17.04.0+ 3.1 1.13.1+ 3.0 1.13.0+ 2.4 17.12.0+ 2.3 17.06.0+ 2.2 1.13.0+ 2.1 1.12.0+ 2.0 1.10.0+ 1.0 1.9.1.+ Compose文件结构和示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192version: \"3\"services: redis: image: redis:alpine ports: - \"6379\" networks: - frontend deploy: replicas: 2 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure db: image: postgres:9.4 volumes: - db-data:/var/lib/postgresql/data networks: - backend deploy: placement: constraints: [node.role == manager] vote: image: dockersamples/examplevotingapp_vote:before ports: - \"5000:80\" networks: - frontend depends_on: - redis deploy: replicas: 2 update_config: parallelism: 2 restart_policy: condition: on-failure result: image: dockersamples/examplevotingapp_result:before ports: - \"5001:80\" networks: - backend depends_on: - db deploy: replicas: 1 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure worker: image: dockersamples/examplevotingapp_worker networks: - frontend - backend deploy: mode: replicated replicas: 1 labels: [APP=VOTING] restart_policy: condition: on-failure delay: 10s max_attempts: 3 window: 120s placement: constraints: [node.role == manager] visualizer: image: dockersamples/visualizer:stable ports: - \"8080:8080\" stop_grace_period: 1m30s volumes: - \"/var/run/docker.sock:/var/run/docker.sock\" deploy: placement: constraints: [node.role == manager]networks: frontend: backend:volumes: db-data: 服务配置指南Compose文件是一个定义服务、网络、挂载卷的YAML文件，默认的路径是./docker-compose.yml。 .yml或.yaml扩展名都是可以的 服务定义包含了应用于该服务所启动的各个容器的配置，就像将命令行参数传递给docker container create一样。同样，网络和卷定义类似于docker network create和docker volume create。 跟docker container create一样，配置项是在Dockerfile中指定的，如CMD, EXPOSE, VOLUME, ENV, 因为这些都是默认的，所以不需要再docker-compose.yml中再次指定。 配置中可以使用类似Bash的${VARIABLE}语法在值中使用环境变量。 build构建时应用的配置。 build可以指定为包含构建上下文路径的字符串： 1234version: '3'services: webapp: build: ./dir 或者作为一个在context下面指定路径的对象以及可选的Dockerfile和args： 12345678version: '3'services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 如果在build时指定image，Compose会按照image中指定的imageName和tag构建镜像： 12build: ./dirimage: webapp:1.0 上面的配置表示从./dir目录构建一个名为webapp标签为1.0的镜像。 该配置项在使用deploying a stack in swarm mode构建时会被忽略。 CONTEXT包含Dockerfile的目录的路径，或者是git仓库的url。 当提供的值是相对路径时，则表示相对于Compose文件的位置。此目录也是发送到Docker守护程序的构建上下文。 12build: context: ./dir DOCKERFILECompose使用备用Dockerfile来构建，同时还必须指定构建路径。 123build: context: . dockerfile: Dockerfile-alternate ARGS添加构建参数，这些参数只能在构建过程中访问。 首先，在Dockerfile中指定参数： 12345ARG buildnoARG gitcommithashRUN echo \"Build number: $buildno\"RUN echo \"Based on commit: $gitcommithash\" 然后在构建键下指定参数。可以传递映射或列表： 1234567891011build: context: . args: buildno: 1 gitcommithash: cdc3b19build: context: . args: - buildno=1 - gitcommithash=cdc3b19 参数也可以省略，在这种情况下，构建时的值是运行Compose的环境中的值。 123args: - buildno - gitcommithash YAML中的布尔值(true, false, yes, no, on, off) 必须用引号括起来，以便解析器将它们解释为字符串。 CACHE_FROM v3.2新增 设置一些引擎用于缓存解决方案的镜像： 12345build: context: . cache_from: - alpine:latest - corp/web_app:3.14 LABELS v3.3新增 使用Docker标签将元数据添加到生成的镜像中。可以使用数组或字典。 建议使用反向DNS表示法来防止标签与其他软件使用的标签冲突。 1234567891011121314build: context: . labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\"build: context: . labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" SHM_SIZE v3.5新增 为此构建的容器设置/dev/shm分区的大小。 指定表示字节数的整数值： 123build: context: . shm_size: 10000000 或表示字节值的字符串：123build: context: . shm_size: '2gb' TARGET v3.4新增 根据Dockerfile中的定义构建指定的阶段： 123build: context: . target: prod cap_add, cap_drop添加或删除容器功能： 123456cap_add: - ALLcap_drop: - NET_ADMIN - SYS_ADMIN 该配置项在使用deploying a stack in swarm mode构建时会被忽略。 command覆盖默认命令： 1command: bundle exec thin -p 3000 该命令也可以是一个列表，方式类似于dockerfile： 1command: [\"bundle\", \"exec\", \"thin\", \"-p\", \"3000\"]","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.wangjin.online/tags/Docker/"},{"name":"Docker Compose","slug":"Docker-Compose","permalink":"http://blog.wangjin.online/tags/Docker-Compose/"}]},{"title":"Thymeleaf用法示例","slug":"Thymeleaf用法示例","date":"2017-12-22T05:15:48.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/12/22/Thymeleaf用法示例/","link":"","permalink":"http://blog.wangjin.online/2017/12/22/Thymeleaf用法示例/","excerpt":"","text":"th:onclick1th:onlick=\"|test('$&#123;param&#125;')|\"","categories":[],"tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://blog.wangjin.online/tags/Thymeleaf/"}]},{"title":"macOS制作CentOS安装U盘","slug":"macOS制作CentOS安装U盘","date":"2017-12-14T11:23:23.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/12/14/macOS制作CentOS安装U盘/","link":"","permalink":"http://blog.wangjin.online/2017/12/14/macOS制作CentOS安装U盘/","excerpt":"","text":"查看U盘第一步，先插入U盘，打开终端使用下面的命令查看U盘是否已经mount到系统，这时在Finder下也能看到U盘。1diskuitl list 终端输出类似如下内容1234567891011121314151617181920wangjindeMacBook-Pro:~ wangjin$ diskutil list/dev/disk0 (internal): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme 251.0 GB disk0 1: EFI EFI 314.6 MB disk0s1 2: Apple_APFS Container disk1 250.7 GB disk0s2/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.7 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 222.4 GB disk1s1 2: APFS Volume Preboot 23.1 MB disk1s2 3: APFS Volume Recovery 506.6 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4/dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *62.1 GB disk2 1: Windows_NTFS WANGJIN 62.1 GB disk2s1 可以看到，上面的/dev/disk2即是U盘挂载点 取消U盘挂载1diskutil unmountDisk /dev/disk2 写入系统镜像到U盘1dd if=/Users/wangjin/Downloads/CentOS-7-x86_64-DVD-1708.iso of=/dev/disk2 bs=1m bs=1m表示设置写入块大小 查看写入进度1sudo killall -29 dd","categories":[],"tags":[{"name":"MAC","slug":"MAC","permalink":"http://blog.wangjin.online/tags/MAC/"},{"name":"macOS","slug":"macOS","permalink":"http://blog.wangjin.online/tags/macOS/"},{"name":"CentOS","slug":"CentOS","permalink":"http://blog.wangjin.online/tags/CentOS/"}]},{"title":"Intellij IDEA配置使用Lombok","slug":"Intellij-IDEA配置使用Lombok","date":"2017-06-12T03:31:21.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/06/12/Intellij-IDEA配置使用Lombok/","link":"","permalink":"http://blog.wangjin.online/2017/06/12/Intellij-IDEA配置使用Lombok/","excerpt":"","text":"安装Lombok插件 开启Annotation Prcessing 添加Lombok依赖12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;","categories":[],"tags":[{"name":"Intellij IDEA","slug":"Intellij-IDEA","permalink":"http://blog.wangjin.online/tags/Intellij-IDEA/"},{"name":"Lombok","slug":"Lombok","permalink":"http://blog.wangjin.online/tags/Lombok/"},{"name":"Java","slug":"Java","permalink":"http://blog.wangjin.online/tags/Java/"}]},{"title":"Spring Data JPA 查询方法名关键字","slug":"Spring-Data-JPA-查询方法名关键字","date":"2017-05-09T03:25:24.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/05/09/Spring-Data-JPA-查询方法名关键字/","link":"","permalink":"http://blog.wangjin.online/2017/05/09/Spring-Data-JPA-查询方法名关键字/","excerpt":"","text":"table{ word-break:break-all; word-wrap:break-all; } 关键字 示例 JPQL片段 And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstname,findByFirstnameIs,findByFirstnameEquals … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection age) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.wangjin.online/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.wangjin.online/tags/Spring/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://blog.wangjin.online/tags/Spring-Data-JPA/"},{"name":"JPA","slug":"JPA","permalink":"http://blog.wangjin.online/tags/JPA/"},{"name":"JPQL","slug":"JPQL","permalink":"http://blog.wangjin.online/tags/JPQL/"}]},{"title":"JavaScript学习笔记","slug":"JavaScript学习笔记","date":"2017-04-28T12:46:23.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/28/JavaScript学习笔记/","link":"","permalink":"http://blog.wangjin.online/2017/04/28/JavaScript学习笔记/","excerpt":"基础知识JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到&lt;head&gt;中：12345678910&lt;html&gt;&lt;head&gt; &lt;script&gt; alert('Hello, world'); // 页面弹出Hello，world提示框 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt;","text":"基础知识JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到&lt;head&gt;中：12345678910&lt;html&gt;&lt;head&gt; &lt;script&gt; alert('Hello, world'); // 页面弹出Hello，world提示框 &lt;/script&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; 由&lt;script&gt;...&lt;/script&gt;包含的代码就是JavaScript代码，它将直接被浏览器执行。 第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入这个文件：12345678&lt;html&gt;&lt;head&gt; &lt;script src=\"abc.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt; 页面加载时，abc.js会被浏览器执行。 把JavaScript代码放入一个单独的.js文件中更利于维护代码，并且多个页面可以各自引用同一份.js文件。 可以在同一个页面中引入多个.js文件，还可以在页面中多次编写&lt;script&gt; js代码... &lt;/script&gt;，浏览器按照顺序依次执行。 &lt;script&gt;标签有一个type属性，该属性默认值为text/javascript，编写代码为JavaScript时可以缺省。 基本语法语法JavaScript的语法和Java语言类似，每个语句以;结束，语句块用{...}。但是，JavaScript并不强制要求在每个语句的结尾加;，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上;。 下面的一行代码就是一个完整的赋值语句：1var x = 1; 下面的一行代码包含两个语句，每个语句用;表示语句结束：1var x = 1; var y = 1; // 不建议一行写多个语句 语句块是一组语句的集合，例如，下面的代码先做了一个判断，如果判断成立，将执行{...}中的所有语句：12345if (2 &gt; 1) &#123; x = 1; y = 2; z = 3;&#125; 注意花括号{...}内的语句具有缩进，通常是4个空格。缩进不是JavaScript语法要求必须的，但缩进有助于我们理解代码的层次，所以编写代码时要遵守缩进规则。很多文本编辑器具有“自动缩进”的功能，可以帮助整理代码。 {...}还可以嵌套，形成层级结构：1234567891011if (2 &gt; 1) &#123; x = 1; y = 2; z = 3; if (x &lt; y) &#123; z = 4; &#125; if (x &gt; y) &#123; z = 5; &#125;&#125; 注释以//开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：12// 这是一行注释alert('hello'); // 这也是注释 另一种块注释是用/*...*/把多行字符包裹起来，把一大“块”视为一个注释：12345/* 从这里开始是块注释仍然是注释仍然是注释注释结束 */alert('hello'); 大小写JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。 数据类型和变量数据类型NumberJavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：123456123; // 整数1230.123; // 浮点数0.1231.23e3; // 科学计数法表示1.23 x 1000 等于 1230-123; // 负数-123NaN; // NaN 表示 not a number，当无法计算结果时用NaN表示Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity Number可以直接做四则运算：1234561 + 2; // 3(1 + 2) * 5 / 2; // 7.52 / 0; // Infinity0 / 0; // NaN10 % 3; // 110.5 % 3; // 1.5 字符串字符串是以单引号&#39;或双引号&quot;括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。 如果&#39;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;It&#39;s OK&quot;包含的字符是I，t, &#39;，s，空格，O，K这7个字符。 如果字符串内部既包含&#39;又包含&quot;，可以用转义字符\\来标识，比如：1'It\\'s \\\"OK\\\"'; // It's \"OK\" 转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\。 ASCII字符以\\x##形式的十六进制表示，例如：12'\\x41'; // 表示'A''\\x61'; // 表示'a' Unicode字符以\\u####形式表示，例如：1'\\u4e2d\\u6587'; // 表示'中文' 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来：1234true; // truefalse; // false1 &lt; 2; // true2 &gt;= 3; // false &amp;&amp;运算是与运算，只有所有都为true，&amp;&amp;运算结果才是true：1234true &amp;&amp; true; // truetrue &amp;&amp; false; // falsefalse &amp;&amp; false; // falsefalse &amp;&amp; true &amp;&amp; false; // false ||运算是或运算，只要其中有一个为true，||运算结果就是true：1234true || true; // truetrue || false; // truefalse || false; // falsefalse || true || false; // true !运算是非运算，它是一个单目运算符，把true变成false，false变成true：123!true; // false!false; // true!(2 &gt; 3); // true 对Number做比较时，可以通过比较运算符得到一个布尔值：1232 &gt; 3; // false3 &gt;= 2; // true1 == 1; // true; JavaScript允许对任意数据类型做比较：12false == 0; // truefalse === 0; // false JavaScript在设计时，有两种比较运算符： ==比较，自动转换数据类型再比较，很多时候，会得到非常诡异的结果； ===比较，不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 NaN这个特殊的Number与所有其他值都不相等，包括它自己：1NaN === NaN; // false null和undefinednull表示一个“空”的值，它和0以及空字符串&#39;&#39;不同，0是一个数值，&#39;&#39;表示长度为0的字符串，而null表示“空”。undefined表示”未定义”。JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 数组数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：1[1, 2, 3.45, 'Hello', null, true]; // 创建数组[1, 2, 3.45, 'Hello', null, true] 上述数组包含6个元素。数组用[]表示，元素之间用,分隔。 另一种创建数组的方法是通过arr()函数实现：1new arr(1, 2, 3.45, 'Hello', null, true); // 创建数组[1, 2, 3.45, 'Hello', null, true] 数组的元素可以通过索引来访问，索引的起始值为0：123456var arr = [1, 2, 3.45, 'Hello', null, true];arr[0]; // 1arr[2]; // 3.45arr[3]; // Helloarr[5]; // truearr[6]; // 索引超出了范围，返回undefined length属性数组的length属性返回数组的长度：12var arr = [1, 2, 3.45, 'Hello', null, true];arr.length; // 6 给数组的length属性赋值会改变数组的长度：1234var arr = [1, 2, 3.45, 'Hello', null, true];arr.length; // 6arr.length = 8; // [1, 2, 3.45, 'Hello', null, true, undefined, undefined]arr.length = 4; // [1, 2, 3.45, 'Hello'] 数组可以通过索引值修改元素的值：12var arr = [1, 2, 3.45, 'Hello', null, true];arr[0] = 'A'; // 数组变为['A', 2, 3.45, 'Hello', null, true] 如果索引值超过了原数组长度，修改数组元素会改变数组的长度：12var arr = [1, 2, 3.45, 'Hello', null, true];arr[6] = 'A'; // 数组变为[1, 2, 3.45, 'Hello', null, true, 'A'] indexOf()数组可以通过indexOf()来搜索一个指定的元素的位置：123456var arr = [1, '2', 3.45, 'Hello', null, true];arr.indexOf(1); // 1的索引位置为0arr.indexOf('2'); // '2'的索引位置为1arr.indexOf(2); // 2不是数组元素，索引为-1arr.indexOf('Hello'); // 'Hello'的索引位置为3arr.indexOf(true); // true的索引位置为5 slice()slice()类似String的substring()，截取数组的部分元素，返回一个新的数组：123var arr = [1, '2', 3.45, 'Hello', null, true];arr.slice(0,3); // 从索引0开始，到索引3，不包括索引3：[1, '2', 3.45]arr.slice(3); // 从索引3开始到结束：['Hello', null, true] slice()的起止参数包括开始索引，不包括结束索引。 如果不给slice()传任何参数，表示截取所有元素，可以利用这一点来复制并创建一个新的数组：123var arr = [1, '2', 3.45, 'Hello', null, true];var arrCopy = arr.slice(); // [1, '2', 3.45, 'Hello', null, true]arr === arrCopy; // false push()和pop()push()向数组的末尾添加若干新元素，pop()则将数组的末尾最后一个元素删掉：123456var arr = [1, '2', 3.45, 'Hello', null, true];arr.push('6'); // [1, '2', 3.45, 'Hello', null, true, '6'];arr.push(7,'A'); // [1, '2', 3.45, 'Hello', null, true, '6', 7,'A'];arr.pop(); // pop返回 'A'，原数组变为[1, '2', 3.45, 'Hello', null, true, '6', 7];arr.pop(); arr.pop(); arr.pop();arr.pop(); arr.pop(); arr.pop();arr.pop(); arr.pop(); // 连续pop8次，原数组变为[]arr.pop(); // 空数组pop不会报错，返回undefined，原数组变为[] unshift()和shift()unshift()向数组的头部添加若干新元素，shift()则将数组的头部第一个元素删掉：123456var arr = [1, '2', 3.45, 'Hello', null, true];arr.unshift('6'); // ['6'，1, '2', 3.45, 'Hello', null, true];arr.unshift(7,'A'); // [7, 'A'，'6'，1, '2', 3.45, 'Hello', null, true];arr.shift(); // pop返回 7，原数组变为['A'，'6'，1, '2', 3.45, 'Hello', null, true];arr.shift(); arr.shift(); arr.shift();arr.shift(); arr.shift(); arr.shift();arr.shift(); arr.shift(); // 连续shift8次，原数组变为[]arr.shift(); // 空数组shift不会报错，返回undefined，原数组变为[] sort()sort()对数组进行排序，默认按照自然顺序排序：12var arr = [6, 4, 1, 3];arr.sort(); // [1, 3, 4, 6] splice()splice()从指定的索引开始删除若干元素，然后再从该位置添加若干元素：1234var arr = [1, '2', 3.45, 'Hello', null, true];arr.splice(2, 3, 'A', 'B'); // 从索引2开始删除3个元素，然后添加两个元素，返回：[3.45, 'Hello', null]，原数组变为：[1, '2', A，B, true]arr.splice(2, 2); // 从索引2开始删除两个元素，不添加任何元素，返回：[A, B]，原数组变为：[1, '2', true]arr.splice(2, 0, 'A', 'B'); // 从索引2开始不删除元素，然后添加两个元素，返回 []，元素组变为：[1, '2', A，B, true] reverse()reverse()对数组进行元素反转：12var arr = [4, 3, 2, 1];arr.reverse(); // [1, 2, 3, 4] concat()concat()将当前数组与另一个数组或若干元素拼接起来，返回新的数组，但是并不修改当前数组：123var arr = [1, '2', 3.45, 'Hello', null, true];arr.concat([1, 2, 3]); // [1, '2', 3.45, 'Hello', null, true, 1, 2, 3]arr.concat(4, 5, ['A', 'B']) // [1, '2', 3.45, 'Hello', null, true, 1, 2, 3，4，5，'A'，'B'] join()join()将数组的元素用指定的字符拼接起来：1234var arr = [1, '2', 3.45];arr.join('-'); // '1-2-3.45'arr = [1, '2', 3.45, 'Hello', null, undefined, NaN, Infinity, true];arr.join('-'); // 当数组中包含：null, undefined, NaN, Infinity等元素时，null与undefined拼接时留空：'1-2-3.45-Hello---NaN-Infinity-true' 对象JavaScript的对象是一种无序的集合数据类型，用{...}表示一个对象，以xxx: xxx键值对形式声明，用,隔开，例如：12345var student = &#123; name : 'Jimmy', age : 20, sex : '男'&#125;; JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述student对象一共定义了3个键值对，其中每个键又称为对象的属性，例如，student的name属性为Jimmy，sex属性为男，要获取一个对象的属性，我们用对象变量.属性名的方式：12student.name; // Jimmystudent.sex; // 男 通过变量.属性名的方式来访问属性要求属性名必须是一个有效的变量名，如果属性名包含特殊字符，就必须用&#39;&#39;括起来：12345var student = &#123; name : 'Jimmy', age : 20, 'middle-school' : '第一中学' &#125;; student的属性middle-school包含特殊字符，不是一个有效的变量名，所以需要用&#39;&#39;括起来，访问这个属性也无法通过变量.属性名的方式，必须用[&#39;属性名&#39;]的方式：123student.name; // Jimmystudent['name']; // Jimmystudent['middle-school']; // 第一中学 如果访问一个不存在的属性名，返回undefined：123456var student = &#123; name : 'Jimmy'&#125;;student.name; // Jimmystudent.age; // undefined JavaScript的对象是动态类型，可以自由得给对象添加和删除属性：1234567891011var student = &#123; name : 'Jimmy'&#125;;student.name; // Jimmystudent.age; // undefinedstudent.age = 18; //新增一个属性agestudent.age; // 18delete student.age; //删除age属性student.age; // undefineddelete xiaoming.school; // 删除一个不存在的属性 使用in来检查JavaScript对象是否包含某属性：12345678var student = &#123; name : 'Jimmy', age : 20, sex : '男'&#125;;'name' in student; // true'school' in student; // false 如果in判断一个属性存在，但这个属性不一定是student的，它可能是student继承得到的：1'toString' in student; // true 因为toString声明在object对象中，而所有对象最终都会在原型链上指向object，所以student也拥有toString属性。 要判断一个属性是否是student自身拥有的，而不是继承得到的，可以用hasOwnProperty()函数：12345678var student = &#123; name : 'Jimmy', age : 20, sex : '男'&#125;;student.hasOwnProperty('name'); // truestudent.hasOwnProperty('toString'); // false 变量变量在JavaScript中用变量名表示，变量名是大小写英文、数字、$和_的组合，且不能以数字开头。变量名不能是JavaScript的关键字，如if、else、while等。声明变量使用var关键字，比如：123var a; // 声明了一个变量a，值为undefinedvar $b = 1; // 声明了一个变量$b，同时给$b赋值，值为1var c = true; // 声明了一个布尔型变量c，值为true JavaScript为弱类型语言，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用var声明一次，例如：12var a = 1; // 声明了一个Number型变量a，并且赋值为1a = 'ABC'; // a重新赋值为ABC，此时a变成字符型 strict模式JavaScript在设计之初，为了方便初学者学习，并不强制要求用var声明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var声明就被使用，那么该变量就自动被声明为全局变量：1a = 1; // a是全局变量 在同一个页面的不同的JavaScript文件中，如果都不用var声明，恰好都使用了变量a，将造成变量a互相影响，产生难以调试的错误结果。 使用var声明的变量则不是全局变量，它的范围被限制在该变量被声明的函数体内，同名变量在不同的函数体内互不冲突。 为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var声明变量，未使用var声明变量就使用的，将导致运行错误。 启用strict模式的方法是在JavaScript代码的第一行写上：1'use strict'; 函数函数声明和调用声明函数在JavaScript中，声明函数的方式如下：123function add(a, b) &#123; return a + b;&#125; function为声明函数的关键字。 add为函数的名称。 (a, b)为函数的参数，多个参数以,分隔。 { ... }之间的代码为函数体，可以包含若干语句，也可以为空。 return为函数返回值关键字。函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。如果没有return语句，函数执行完毕后返回undefined。 由于JavaScript的函数也是一个对象，而函数名add可以视为指向该函数的变量，因此函数也可以这样声明：123var add = function(a, b) &#123; return a + b;&#125;; function(x) { ... }是一个匿名函数，没有函数名，但赋值给了add，所以通过变量add就可以调用函数，两种声明函数的方式是完全等价的。 调用函数调用函数时，按顺序传入参数即可：123456var add = function(a, b) &#123; return a + b;&#125;;add(1, 2); // 3add(1, 3); // 4 JavaScript允许传入任意个参数而不影响调用，传入的参数比声明的参数多也没有问题，虽然函数内部并不需要这些参数：12add(1, 2, 5, 6); // 3add(1, 3, 7, 8); // 4 传入的参数少于要求参数也可以：12add(1); // NaNadd(); // NaN 此时参数a,b为undefined，因此计算的值为NaN，要避免接收的参数为undefined，可以对参数进行检查：123456789101112function add(a, b)&#123; if(typeof a !== 'number')&#123; throw 'a is not a number!'; &#125; else if(typeof b !== 'number')&#123; throw 'b is not a number!'; &#125; return a + b;&#125;add(1); // 抛出异常：'b is not a number!'add(); // 抛出异常：'a is not a number!' 变量作用域如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：123456function foo() &#123; var x = 1; x = x + 1;&#125;x = x + 2; // ReferenceError! 无法在函数体外引用变量x 如果两个不同的函数各自声明了同一个同名变量，那么该变量只在各自的函数体内起作用。不同函数内部的同名变量互相独立，互不影响：123456789function foo() &#123; var x = 1; x = x + 1;&#125;function bar() &#123; var x = 'A'; x = x + 'B';&#125; JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数声明的变量，反过来则不行：1234567function foo() &#123; var x = 1; function bar() &#123; var y = x + 1; // bar可以访问foo的变量x! &#125; var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!&#125; 如果内部函数和外部函数声明的变量同名，函数在查找变量时从自身函数声明开始，从“内”向“外”查找，内部函数的变量将“屏蔽”外部函数的变量：123456789function foo() &#123; var x = 1; function bar() &#123; var x = 'A'; alert('x in bar() = ' + x); // x in bar() = A &#125; alert('x in foo() = ' + x); // x in foo() = 1 bar();&#125; 变量提升JavaScript的函数在执行时，会先扫描整个函数体的语句，把所有声明的变量“提升”到函数顶部：123456789'use strict';function foo() &#123; var x = 'Hello, ' + y; alert(x); var y = 'Bob';&#125;foo(); 虽然是strict模式，但语句var x = &#39;Hello, &#39; + y;并不报错，因为变量y在稍后声明了。但是alert显示Hello, undefined，说明变量y的值为undefined。因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 对于上述foo()函数，JavaScript引擎看到的代码相当于：123456function foo() &#123; var y; // 提升变量y的声明 var x = 'Hello, ' + y; alert(x); y = 'Bob';&#125; 全局作用域不在任何函数内定义的变量就具有全局作用域。JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：12345'use strict';var a = 'A';alert(a); // 'A'alert(window.a); // 'A' 直接访问全局变量a和访问window.a是完全一样的。 以变量方式var foo = function () { ... }定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：12345678'use strict';function foo() &#123; alert('foo');&#125;foo(); // 直接调用foo()window.foo(); // 通过window.foo()调用 名字空间全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者声明了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中：12345678910111213'use strict';var consts = &#123;&#125;; // 唯一的全局变量constsconsts.name = 'A'; // 全局变量nameconsts.version = 1.0; // 全局变量versionconsts.foo = function() &#123; // 全局函数foo return 'foo';&#125;function bar()&#123; return consts.name; // 使用全局变量name&#125; 局部作用域JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：12345678'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; //循环语句 &#125; i += 100; // 仍然可以引用变量i&#125; 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以声明一个块级作用域的变量：123456789'use strict';function foo() &#123; var sum = 0; for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; i += 1; // SyntaxError&#125; 常量由于var和let声明的是变量，如果要声明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：12345'use strict';const PI = 3.14;PI = 3; // 某些浏览器不报错，但是无效果！PI; // 3.14 方法在对象中绑定函数，就称为这个对象的方法：123456789var student = &#123; name : 'Jimmy', birthday : 1988, age : function()&#123; return new Date().getFullYear() - birthday; &#125;&#125;;student.age(); // 调用age()方法得到结果：29 绑定到对象上的函数称为方法，和普通函数没有区别，但是它在内部有一个this关键字，this是一个特殊变量，它始终指向当前对象，也就是student这个变量。所以，this.birthday可以拿到student的birthday属性。 如果在单独的函数中使用this：123456789101112131415function getAge()&#123; return new Date().getFullYear() - this.birthday;&#125;var student = &#123; name : 'Jimmy', birthday : 1988, age : getAge&#125;;student.age(); // 调用age()方法得到结果：29getAge(); // 单独调用：NaNvar fn = student.age;fn(); // NaN 如果以对象的方法形式调用，比如student.age()，该函数的this指向被调用的对象，也就是student。如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。如果将student.age赋值给fn，此时，该函数的this也指向全局对象。 在strict模式下，上述情况的this指向undefined，而不是全局对象window，执行时会抛出TypeError: Cannot read property &#39;birthday&#39; of undefined异常。 在函数内部声明函数时也会遇到this指向不正确的情况：12345678910111213var student = &#123; name : 'Jimmy', birthday : 1988, age : function()&#123; function getAge() &#123; return new Date().getFullYear() - this.birthday; &#125; return getAge(); &#125;&#125;;student.age(); // strict模式下this指向全局对象window，函数执行返回：NaN，strict模式下this指向undefined，函数执行抛出TypeError: Cannot read property 'birthday' of undefined异常 可以通过声明一个变量来捕获this：1234567891011121314var student = &#123; name : 'Jimmy', birthday : 1988, age : function()&#123; var that = this; function getAge() &#123; return new Date().getFullYear() - that.birthday; &#125; return getAge(); &#125;&#125;;student.age(); // 28 用var that = this;来解决this指向问题，就可以放心在函数内部声明其他函数，而不是将所有的语句写在一个函数中。 apply在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们可以用过apply控制this的指向。函数的apply方法接收两个参数，第一个参数是需要绑定的this变量，第二个是参数数组，表示函数本身的参数：123456789101112function getAge()&#123; return new Date().getFullYear() - this.birthday;&#125;var student = &#123; name : 'Jimmy', birthday : 1988, age : getAge&#125;;student.age(); // 28getAge.apply(student,[]); // 28，this指向student，参数数组为空 高阶函数一个函数就接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数：123function add(x, y, f) &#123; return f(x) + f(y);&#125; 当我们调用add(-1, 2, Math.abs)时，参数x，y和f分别接收-1，2和函数Math.abs，根据函数定义，我们可以推导计算过程为：12345x = -1;y = 2;f = Math.abs;f(x) + f(y) =&gt; Math.abs(-1) + Math.abs(2) =&gt; 3;return 3; 用代码验证一下：1add(-1, 2, Math.abs); // 3 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.wangjin.online/tags/JavaScript/"}]},{"title":"Git添加多remote","slug":"Git添加多remote","date":"2017-04-14T07:06:46.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/14/Git添加多remote/","link":"","permalink":"http://blog.wangjin.online/2017/04/14/Git添加多remote/","excerpt":"","text":"添加remote1$ git remote add [remote名称] &lt;git_url&gt; 删除remote1$ git remote remove [remote名称] &lt;git_url&gt; 添加多个同名remote1$ git remote set-url --add [remote名称] &lt;git_url&gt; 删除同名remote1$ git remote set-url --delete [remote名称] &lt;git_url&gt; 配置保存在.git/config文件中","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://blog.wangjin.online/tags/git/"},{"name":"remote","slug":"remote","permalink":"http://blog.wangjin.online/tags/remote/"}]},{"title":"OSX通过Homebrew安装JDK","slug":"OSX通过Homebrew安装JDK","date":"2017-04-13T01:17:51.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/13/OSX通过Homebrew安装JDK/","link":"","permalink":"http://blog.wangjin.online/2017/04/13/OSX通过Homebrew安装JDK/","excerpt":"","text":"安装Homebrew1$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装Homebrew Cask1$ brew tap caskroom/cask 应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。 几乎所有常用的应用都可以通过 brew-cask 安装，而且是从应用的官网上下载，所以你要安装新的应用时，建议用 brew-cask 安装。如果你不知道应用在 brew-cask 中的 ID，可以先用brew cask search命令搜索 Homebrew Cask官网 安装JDK1$ brew cask install java 如果提示已经安装，则使用1$ brew cask reinstall java 如果你需要安装指定版本，可以使用homebrew-cask-versions12brew tap caskroom/versionsbrew cask install java8 更新cask安装应用1brew cask upgrade 测试JDK是否正确安装1$ java -version 安装多个JDK版本并切换使用brew cask安装JDK 123brew cask install java6 #JDK6brew cask install java8 #JDK8brew cask install java #目前最新java 修改shell(.bash_profile,.bashrc,.zshrc)配置添加切换 12345678# Switch JDKexport JAVA_6_HOME=\"/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home\"export JAVA_8_HOME=\"/Library/Java/JavaVirtualMachines/jdk1.8.0_172.jdk/Contents/Home\"export JAVA_11_HOME=\"/Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home\"export JAVA_HOME=$JAVA_8_HOME # Default JDK8alias jdk6=\"export JAVA_HOME=$JAVA_6_HOME;java -version\" # to JDK6 alias jdk8=\"export JAVA_HOME=$JAVA_8_HOME;java -version\" # to JDK8alias jdk11=\"export JAVA_HOME=$JAVA_11_HOME;java -version\" # to 最新JDK","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.wangjin.online/tags/Mac/"},{"name":"OSX","slug":"OSX","permalink":"http://blog.wangjin.online/tags/OSX/"},{"name":"Homebrew","slug":"Homebrew","permalink":"http://blog.wangjin.online/tags/Homebrew/"},{"name":"JDK","slug":"JDK","permalink":"http://blog.wangjin.online/tags/JDK/"}]},{"title":"JavaEE的13种核心技术规范","slug":"JavaEE的13种核心技术规范","date":"2017-04-11T13:11:39.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/11/JavaEE的13种核心技术规范/","link":"","permalink":"http://blog.wangjin.online/2017/04/11/JavaEE的13种核心技术规范/","excerpt":"JDBC（Java Database）数据库连接JDBC是一组用于执行SQL的Java API ，为访问不同的数据库提供了一种统一的途径，几乎所有的关系型数据库厂商（DBMS）都提供了JDBC的服务或驱动。JDBC对数据库的访问也具有平台无关性。","text":"JDBC（Java Database）数据库连接JDBC是一组用于执行SQL的Java API ，为访问不同的数据库提供了一种统一的途径，几乎所有的关系型数据库厂商（DBMS）都提供了JDBC的服务或驱动。JDBC对数据库的访问也具有平台无关性。 JNDI（Java Naming and Directory Interfaces）Java 的命名和目录接口JNDI是命名目录服务的抽象接口集合，为企业级应用提供了统一的标准化连接，使Java能够无缝地获取任何可目录化的企业信息。在JavaEE体系中，JNDI用来定位各种对象，包括EJB、数据库驱动、JDBC数据源及消息连接等。由于JNDI是独立于目录协议的，因此还可以用JNDI访问各种特定的目录服务，如LDAP（轻量目录访问协议）、NDS（服务器目录访问服务）。 EJB（Enterprise JavaBean）EJB组件：JavaBean是在编程环境（IDE）中能够被可视化处理的可重用组件，是实现分布式业务逻辑的 Java 组件。我们在开发的时候可以利用这些组件，像搭积木一样建立面向对象的分布式应用。EJB容器：是EJB组件的运行环境，为部署EJB组件提供服务，包括事务、安全、远程客户端的网络发布、资源管理等。EJB服务器：管理EJB容器的高端进程或应用程序，并提供对系统服务的访问。调用EJB组件的应该称为EJB客户端，客户端可以运行在Web容器中。 RMI（Remote Method Invoke）远程方法调用RMI协议能够让在某个Java虚拟机上的对象，像调用本地对象一样调用另一个Java虚拟机中的对象上的方法。它使用了序列化方式在客户端和服务器端传送数据。RMI是一种被EJB使用的更底层的协议。（stub/skeleton层提供了客户程序和服务程序彼此交互的接口） Java IDL（Interface Description Language）/CORBA（Common Object Broker Architecture）Java 接口定义语言/公用对象请求代理程序体系结构IDL是用来描述软件组件接口的一种计算机语言。IDL通过一种中立的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流。 JSP（Java Server Pages）JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端所请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。JSP可以使用Servlet提供的API，一般和JavaBean结合使用，从而将界面表现和业务逻辑分离。 ServletServlet是一种小型的Java程序，它扩展了Web服务器的功能。作为一种服务器端的应用，当被请求时开始执行。Servlet提供的功能大多与JSP类似，不过实现的方式不同。JSP通常是大多数HTML代码中嵌入少量的Java代码，而servlets全部由Java写成并且生成HTML。 XML（Extensible Markup Language）可扩展白标记语言XML是一种用于标记电子文件使其具有结构性的标记语言。它被用来在不同的商务过程中共享数据。XML的发展和Java是相互独立的，但是它和Java有着相同的目标，即平台独立性。通过Java和XML的组合，可以得到一个完美的具有平台独立性的解决方案。 JMS（Java Message Service）Java 消息服务JMS是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS用于和面向消息的中间件相互通信的应用程序接口(API)。它既支持点对点的域，有支持发布/订阅(publish/subscribe)类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。JMS消息系统带来的好处： 提供消息灵活性 松散耦合 异步性 JTA（Java Transaction API）Java 事务 API在JavaEE应用中，事务是一个不可或缺的组件模型，它保证了用户操作ACID（即原子、一致、隔离、持久）属性。对于那些跨数据源（例如多个数据库，或者数据库与JMS）的大型应用，则必须使用全局事务JTA。应用系统可以由JTA定义的标准API访问各种事务监控，JTA为JavaEE平台提供了分布式事务服务，它隔离了事务与底层的资源，实现了透明的事务管理方式。 JTS（Java Transaction Service）Java 事务服务JTS是一个组件事务监视器。JTS是CORBA OTS事务监控的基本实现。JTS规定了事务管理器的实现方式。JTS事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。 JavaMailJavaMail是用于存取邮件服务器的API，它提供了一套邮件服务器的抽象类。不仅支持SMTP服务器，也支持IMAP服务器和POP服务器。 JAF（JavaBean Activation Framework）JavaMail利用JAF来处理MIME编码的邮件附件。MIME的字节流可以被转换成Java对象，或者转换自Java对象。大多数应用都可以不需要直接使用JAF。 JavaEE软件开发体系架构两层架构传统的客户服务器系统仅只简单地基于两层体系来构建，即客户端（前台）和企业信息系统（后台），没有任何中间件，业务逻辑层与表示层或数据层混在一起。这种两层架构无论从开发、部署、扩展、维护来说，综其只有一个特点——成本高。 三层架构三层架构自上而下将系统分为表示层、逻辑层、持久层。表示层由处理用户交互的客户端组件及其容器所组成；业务逻辑层由解决业务问题的组件组成；数据层由一个或多个数据库组成，并可包含存储过程。这种三层架构，在处理客户端的请求时，使客户端不用进行复杂的数据库处理；透明地为客户端执行许多工作，如查询数据库、执行业务规则和连接现有的应用程序；并且能够帮助开发人员创建适用于企业的大型分布式应用程序。 MVC在MVC模式中，应用程序被划分为模型层（Model）、视图层（View）、控制层（Controller）三部分。MVC模型就是把一个应用程序的开发按照业务逻辑、数据、视图进行分离分层并组织代码。MVC要求把应用的模型按一定的层次规则抽取出来，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。模型层负责封装应用的状态，并实现功能，视图层负责将内容呈现给用户，控制层负责控制视图层发送的请求以及程序的流程。Servlet+JSP+JavaBean（MVC）这种模式比较适合开发复杂的web应用，在这种模式下，Servlet负责处理用户请求，JSP负责数据显示，JavaBean负责封装数据。 基于JavaEE架构模式下的MVC在这种架构模式下，模型层（Model）定义了数据模型和业务逻辑。为了将数据访问与业务逻辑分离，降低代码之间的耦合，提高业务精度，模型层又具体划分为了DAO层和业务层，DAO即Data Access Object，其主要职能是将访问数据库的代码封装起来，让这些代码不会在其它层出现或者暴露出来给其它层；业务层是整个系统最核心也是最具有价值的一层，该层封装应用程序的业务逻辑，处理数据，关注客户需求，在业务处理过程中会访问原始数据或产生新数据，DAO层提供的DAO类能很好地帮助业务层完成数据处理，业务层本身侧重于对客户需求的理解和业务规则的适应，总体说来，DAO层不处理业务逻辑，只为业务层提供辅助，完成获取原始数据或持久层数据等操作。 JSP：JSP被用来产生Web的动态内容。这层把应用数据以网页的形式呈现给浏览器，然后数据按照在JSP中开发的预定的方式表示出来，这层也可以称之为布局层。 Servlet：JSP建立在Servlet之上，Servlet是J2EE的重要组成部分。Servlet负责处理用户请求，Java Web项目的所有配置都写在了web.xml配置文件里，当项目运行的时候，web.xml会将http请求映射给对应的Servlet类。 JavaBean：由一些具有私有属性的Java类组成，对外提供get和set方法。JavaBean负责数据，负责处理视图层和业务逻辑之间的通信。 Service：业务处理类，对数据进行一些预处理。 DAO：数据访问层，JDBC调用存储过程，从数据库（DataBase）那里获取到数据，再封装到Model实体类中去。 本文转自简书","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.wangjin.online/tags/Java/"},{"name":"JavaEE","slug":"JavaEE","permalink":"http://blog.wangjin.online/tags/JavaEE/"}]},{"title":"Mac上通过nvm安装Node.js","slug":"Mac上通过nvm安装Node.js","date":"2017-04-11T09:22:12.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/11/Mac上通过nvm安装Node.js/","link":"","permalink":"http://blog.wangjin.online/2017/04/11/Mac上通过nvm安装Node.js/","excerpt":"","text":"安装nvm（0.33.1版本）1$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 具体版本查看GitHub 查看可安装版本1$ nvm ls-remote 安装Node.js（7.8.0版本）1$ nvm install v7.8.0 查看本地已安装的版本1$ nvm ls 切换默认Node.js版本1$ nvm alias default v7.8.0 查看Node及npm版本12$ node -v$ npm -v","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.wangjin.online/tags/Mac/"},{"name":"OSX","slug":"OSX","permalink":"http://blog.wangjin.online/tags/OSX/"},{"name":"Node","slug":"Node","permalink":"http://blog.wangjin.online/tags/Node/"},{"name":"Node.js","slug":"Node-js","permalink":"http://blog.wangjin.online/tags/Node-js/"},{"name":"nvm","slug":"nvm","permalink":"http://blog.wangjin.online/tags/nvm/"}]},{"title":"Spring Boot 配置SSL","slug":"Spring-Boot-配置SSL","date":"2017-04-10T08:43:22.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/10/Spring-Boot-配置SSL/","link":"","permalink":"http://blog.wangjin.online/2017/04/10/Spring-Boot-配置SSL/","excerpt":"","text":"生成ssl证书证书颁发机构CA机构私钥1$ openssl genrsa -out ca.key 2048 CA证书生成过程中需要输入CA机构信息 1$ openssl req -x509 -new -key ca.key -out ca.crt 服务端证书生成服务端私钥1$ openssl genrsa -out server.key 2048 生成服务端证书请求文件生成过程中需要输入服务端信息 1$ openssl req -new -key server.key -out server.csr 使用CA证书生成服务端证书1$ openssl x509 -req -sha256 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out server.crt 关于sha256，默认使用的是sha1，在新版本的chrome中会被认为是不安全的，因为使用了过时的加密算法 打包服务端的资料为pkcs12格式(非必要，只是换一种格式存储上一步生成的证书)1$ openssl pkcs12 -export -in server.crt -inkey server.key -out server.pkcs12 生成过程中，需要创建访问密码 生成服务端的keystore（.jks文件, 非必要，Java程序通常使用该格式的证书）1$ keytool -importkeystore -srckeystore server.pkcs12 -destkeystore server.jks -srcstoretype pkcs12 生成过程中，需要创建访问密码 把ca证书放到keystore中（非必要）1$ keytool -importcert -keystore server.jks -file ca.crt 配置tomcat ssl信息使用上面生成的jks证书 123server.ssl.key-store=classpath:证书.jksserver.ssl.key-store-password=创建证书时设定的密码server.ssl.key-password=创建证书时设定的密码 总结 crt、jks、pkcs12都是保存证书的不同格式，不同的应用服务器可能会使用不同格式的证书文件 OpenSSl、Keytool都可以用来生成证书，其中OpenSSl功能更多更复杂，keytool是JDK中自带的","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.wangjin.online/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.wangjin.online/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.wangjin.online/tags/Spring-Boot/"},{"name":"SSL","slug":"SSL","permalink":"http://blog.wangjin.online/tags/SSL/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://blog.wangjin.online/tags/HTTPS/"}]},{"title":"Spring Boot 自定义错误页","slug":"Spring-Boot-自定义错误页","date":"2017-04-10T01:28:25.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/10/Spring-Boot-自定义错误页/","link":"","permalink":"http://blog.wangjin.online/2017/04/10/Spring-Boot-自定义错误页/","excerpt":"","text":"在Spring Boot自定义错误页面添加Java风格配置123456789101112@Configurationpublic class ErrorPageConfig &#123; @Bean public EmbeddedServletContainerCustomizer containerCustomizer() &#123; return container -&gt; &#123; container.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, \"/400\")); container.addErrorPages(new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, \"/500\")); container.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, \"/404\")); &#125;; &#125;&#125; Controller中添加RequestMapping绑定自定义页面1234567891011@RequestMapping(value = \"/404\")public String pageNotFound() &#123; return \"base/404\";&#125;@RequestMapping(value = \"/500\")public String serverError() &#123; return \"base/500\";&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.wangjin.online/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.wangjin.online/tags/Spring/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.wangjin.online/tags/Spring-Boot/"}]},{"title":"第一篇博客","slug":"first-blog","date":"2017-04-09T00:54:38.000Z","updated":"2019-03-22T08:45:46.632Z","comments":true,"path":"2017/04/09/first-blog/","link":"","permalink":"http://blog.wangjin.online/2017/04/09/first-blog/","excerpt":"","text":"从事IT行业很多年了，居然一直都没有搭建一个属于自己的博客来记录一些学习心得和解决问题的方法和思路。最近突然想起来，决定慢慢要把博客这块整起来，正好顺便学习下markdown语法。同时也把平时遇到问题时找到的解决方法记录到自己的博客里，方便自己回顾。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://blog.wangjin.online/tags/随笔/"}]}]}